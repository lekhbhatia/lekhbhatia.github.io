<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-10-05">

<title>Why I Love Integration by Parts – Thoughts From A Lake</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Thoughts From A Lake</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#statement" id="toc-statement" class="nav-link active" data-scroll-target="#statement">Statement</a></li>
  <li><a href="#practice" id="toc-practice" class="nav-link" data-scroll-target="#practice">Practice</a></li>
  <li><a href="#theory" id="toc-theory" class="nav-link" data-scroll-target="#theory">Theory</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Why I Love Integration by Parts</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 5, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Analysis is a vast field, and there is a great deal I can say about why I find it beautiful. However, a common adage conveys the beauty quite concisely: analysis is not about objects, it is about actions. The subjects of interest are not all-encompassing theorems about the macroscopic structure of the field, but rather the usage of ingenious tools to analyze a class of objects. I can find countless examples in harmonic, functional, stochastic, geometric, or microlocal analysis.</p>
<p>Integration by parts (IBP) is one such ingenious tool which most students will learn in high school, and yet it evades the interest of most undergraduate mathematics students. In this article I will hopefully convince you that it should be of great interest. I love it, and you should too. I break apart this discussion broadly into two focuses: practice and theory.</p>
<section id="statement" class="level3">
<h3 class="anchored" data-anchor-id="statement">Statement</h3>
<p>In high school we learn that for <span class="math inline">\(f,g\in C^1(\mathbb R)\)</span> <span class="math display">\[
\int f'g \mathrm d x = fg - \int g'f \mathrm d x
\]</span> which can be derived with nothing more than the product rule and an application of the fundamental theorem of calculus<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. To be a little pedantic, neither of these integrals is necessarily well defined. For a proper treatment of integration by parts, we would have to further impose something like <span class="math inline">\(f,f'\in L^p(\mathbb R)\)</span> and <span class="math inline">\(g,g' \in L^q(\mathbb R)\)</span> such that <span class="math inline">\(\frac{1}{p} + \frac{1}{q} = 1\)</span>. However, you can simply ignore these conditions if you don’t know what those spaces are. <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
</section>
<section id="practice" class="level3">
<h3 class="anchored" data-anchor-id="practice">Practice</h3>
<p>Let us say that I have some function <span class="math inline">\(f \in C^\infty_c(\mathbb{R})\)</span> which is smooth and compactly supported. Of course, some of these arguments can be modified for a weaker class of <span class="math inline">\(f\)</span>, but I don’t want to get into the weeds here. Simply speaking, all I require from <span class="math inline">\(f\)</span> is that it is integrable and that</p>
<p><span class="math display">\[
\frac{\mathrm d^n f}{\mathrm d x^n} &lt; \infty
\]</span></p>
<p>for all <span class="math inline">\(n \in \mathbb N\)</span> up to some sufficiently high amount of regularity. If <span class="math inline">\(f\)</span> is smooth, this is indeed all <span class="math inline">\(n\)</span>. We will try to prove a version of the <a href="https://en.wikipedia.org/wiki/Riemann%E2%80%93Lebesgue_lemma">Riemann–Lebesgue Lemma</a> for this <span class="math inline">\(f\)</span>; that the Fourier transform vanishes at infinity. Consider the Fourier transform of <span class="math inline">\(f\)</span> using the convention provided in <a href="https://link.springer.com/book/9783031907050">Hintz’s notes</a>. <span class="math display">\[
\widehat f(\xi) = \int_{-\infty}^\infty e^{-ix\xi} f(x) \mathrm d x
\]</span> Note that <span class="math display">\[
\frac{\mathrm d}{\mathrm d x}(e^{-ix\xi}) = -i\xi e^{-ix\xi}.
\]</span> This self referential derivative is key. It will allow us to now use IBP on the Fourier transform. <span class="math display">\[
\widehat f(\xi) = \int_{-\infty}^\infty e^{-ix\xi} f(x) \mathrm d x = \left. \left(\frac{e^{-ix\xi}}{-i\xi} f(x)\right)\right|_{-\infty}^\infty-\int_{-\infty}^\infty \frac{e^{-ix\xi}}{-i\xi} f'(x) \mathrm d x
\]</span> By the fact that <span class="math inline">\(f\)</span> is compactly supported, we expect that the first term in the final expression should vanish. In particular <span class="math display">\[
\widehat f(\xi) = \frac{1}{i\xi}\int_{-\infty}^\infty e^{-ix\xi} f'(x) \mathrm d x.
\]</span> If <span class="math inline">\(f\)</span> indeed has a well-defined integrable first derivative, we can do the following estimate using that <span class="math inline">\(|e^{-ix\xi}| \leq 1\)</span> <span class="math display">\[
|\widehat f(\xi)| = \left|\frac{1}{i\xi}\int_{-\infty}^\infty e^{-ix\xi} f'(x) \mathrm d x\right| = \frac{1}{|\xi|}\left|\int_{-\infty}^\infty e^{-ix\xi} f'(x) \mathrm d x\right| \leq \frac{1}{|\xi|}\left|\int_{-\infty}^\infty f'(x) \mathrm d x\right| \leq \frac{1}{|\xi|}\int_{-\infty}^\infty |f'(x)| \mathrm d x.
\]</span> The integral here is simply some fixed constant dependent on your choice of <span class="math inline">\(f\)</span> and entirely independent of <span class="math inline">\(\xi\)</span>. So indeed as <span class="math inline">\(|\xi| \to \infty\)</span> the Fourier transform must vanish. The integral here is the <span class="math inline">\(L^1\)</span>-norm of <span class="math inline">\(f\)</span>. If we are fortunate enough that <span class="math inline">\(f\)</span> is <span class="math inline">\(C^2\)</span> or twice differentiable, we can do another IBP and show that <span class="math display">\[
|\widehat f(\xi)| \leq \frac{\lVert f^{(2)}\rVert_{L^1(\mathbb R)}}{|\xi|^2}
\]</span> and the decay is just a little bit stronger. The punchline here is that if <span class="math inline">\(f\)</span> happens to be smooth, or infinitely differentiable, then we can show that for any <span class="math inline">\(N\)</span> <span class="math display">\[
|\widehat f(\xi)| \leq \frac{\lVert f^{(N)}\rVert_{L^1(\mathbb R)}}{|\xi|^N}.
\]</span> Indeed, we can prove a version of the Riemann-Lebesgue Lemma with this method, but also prove that the Fourier transform of any smooth function which vanishes at <span class="math inline">\(\pm\infty\)</span> must be rapidly decaying.</p>
<p><strong>What is really going on?</strong> Effectively, the Fourier transform is the integral of a highly oscillatory function against a slowly oscillating, or non-oscillating function. Imagine you take the integral of <span class="math inline">\(\sin (\omega x)\)</span> for <span class="math inline">\(\omega \in \mathbb R\)</span> against some function which is very close to 1 on the unit interval, and smoothly decays to 0. For large enough <span class="math inline">\(\omega\)</span> to induce heavy oscillations in <span class="math inline">\(\sin\)</span> we should see that the positive area contributions and negative area contributions will mostly cancel with each other in a symmetric-ish way. With this picture in mind, the result is not surprising at all.</p>
<p><strong>How does IBP fit in?</strong> In some sense, IBP is providing you with a way to transfer regularity. As long as you have a sufficiently well behaved function, you can throw derivatives from your highly oscillatory term onto this well behaved function with little consequences. In the process you will recover decay factors which help you prove neat results. When I first saw this technique, I thought it was magic. I have now seen it being applied tens of times in assignments, lectures, and papers. It feels no less like magic.</p>
</section>
<section id="theory" class="level3">
<h3 class="anchored" data-anchor-id="theory">Theory</h3>
<p>There are probably many aspects of mathematical theory building which I could argue arise from IBP. However, I would be lying if I did not admit that most of these are in fact simply some kind of <a href="https://ncatlab.org/nlab/show/derivation">Leibniz rule</a> (rare instance of reasonable nLab post). However, I do believe there is one theory building aspect where it is uniquely the “integrative” nature of IBP which helps us out.</p>
<p>This is the notion of “weak”-ness in the world of PDE. Let us consider the function <span class="math display">\[
f(x) = \begin{cases}
0 &amp; x&lt; 0\\
x &amp; x\geq 0
\end{cases}.
\]</span></p>
<p>In a vague sense, this function is differentiable with derivative given by <span class="math display">\[
v(x) = \begin{cases}
0 &amp; x&lt;0\\
1 &amp; x\geq 0
\end{cases}
\]</span></p>
<p>with the obvious caveat of non-differentiability at just a single point. While this is an imprecise statement, we as humans understand what we mean by writing something like this down. We effectively want to ignore the behaviour which is only captured on irrelevant sets (sets of measure zero). Integration by parts provides the natural idea. If we suspend disbelief for one second and assume that <span class="math inline">\(f\in C^1(\mathbb R)\)</span>, then it must be by IBP that for any <span class="math inline">\(\phi\in C^\infty_c(\mathbb R)\)</span></p>
<p><span class="math display">\[
\int f \phi' = -\int f' \phi
\]</span></p>
<p>where <span class="math inline">\(f'\)</span> is what we mean by the usual derivative of <span class="math inline">\(f\)</span> which is entirely well defined. In our example, <span class="math inline">\(f'\)</span> simply does not exist, but we do have a function <span class="math inline">\(v\)</span> such that for all <span class="math inline">\(\phi\in C^\infty_c(\mathbb R)\)</span></p>
<p><span class="math display">\[
\int f \phi' = -\int v \phi.
\]</span></p>
<p>We say that if <span class="math inline">\(v\)</span> satisfies this property for some possibly very irregular <span class="math inline">\(f\)</span>, then it is the weak derivative of <span class="math inline">\(f\)</span>. We use integration by parts to create a natural notion of a weak derivative. Formally, we can view the weak derivative in a distributional sense. We define the functional <span class="math inline">\(v\)</span> as the map from <span class="math inline">\(C^\infty_c(\mathbb R) \to \R\)</span> which maps</p>
<p><span class="math display">\[
\phi \mapsto -\int f \phi'.
\]</span></p>
<p><span class="math inline">\(v\)</span> is the weak derivative of <span class="math inline">\(f\)</span> and it can act on smooth functions with this integration. The easiest example of this is the Dirac-Delta function. Let <span class="math inline">\(f\)</span> be the indicator function on the positive reals. We define the Dirac-Delta function <span class="math inline">\(\delta\)</span> to be its weak derivative. This is not a function in any traditional sense, but it has the expected behaviour via the integral:</p>
<p><span class="math display">\[
\phi \mapsto -\int_0^\infty \phi' = \left. (-\phi)\right|_0^\infty = \phi(0)
\]</span></p>
<p>where we have just used the fundamental theorem of calculus. We are somehow able to capture the behaviour of what it means for <span class="math inline">\(f\)</span> to jump up rapidly at the origin, in a completely formal setting. Of course, if the natural derivative of <span class="math inline">\(f\)</span> exists already, we know that <span class="math inline">\(v\)</span> will directly coincide with <span class="math inline">\(f'\)</span> as well.</p>
<p><strong>What else can we do?</strong> We can also consider a notion of a weak solution to a PDE. I would say that a function <span class="math inline">\(f\in C^2(\mathbb R)\)</span> is a solution to Laplace’s equation if</p>
<p><span class="math display">\[
\frac{\mathrm d^2 f}{\mathrm d x^2} = 0.
\]</span></p>
<p>What if <span class="math inline">\(f\)</span> is not <span class="math inline">\(C^2\)</span>, but only <span class="math inline">\(C^1\)</span>? Then we can weaken our notion of a solution slightly. We say that <span class="math inline">\(f\)</span> is a weak solution to Laplace’s equation if for all <span class="math inline">\(\phi \in C^\infty_c(\mathbb R)\)</span></p>
<p><span class="math display">\[
\int \frac{\mathrm d f}{\mathrm d x} \phi' = 0
\]</span></p>
<p>which only requires first derivatives. Maybe we don’t even have that. We can do IBP once more and move the final derivative onto <span class="math inline">\(\phi\)</span> and say that a weak solution is one such that for all <span class="math inline">\(\phi \in C^\infty_c(\mathbb R)\)</span></p>
<p><span class="math display">\[
\int f \phi'' = 0.
\]</span></p>
<p>This means that for any given PDE problem, there are multiple notions of a weak solution, most of which are inspired from integration by parts. It is a vital skill in solving PDEs to select the appropriate level of “weakness” of your solutions. However, I can certainly leave the more nuanced discussion of these ideas to <a href="https://www.amazon.com.au/Partial-Differential-Equations-Lawrence-Evans/dp/0821849743">Evans</a> or <a href="https://link.springer.com/book/10.1007/978-1-4419-7055-8">Taylor</a>.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>I have oft heard the argument that since it is easy to derive via other seemingly more “elementary” or “foundational” results, that IBP certainly shouldn’t be of much interest in and of itself. I find that this sort of thinking is antithetical to the pursuit of research in analysis. It is often the case that very simple methods are quite difficult to come by, and can go a very long way. It is with the presentation of IBP as a method in and of itself that we have made so much progress using it. To beat an analogy to death, I think this is because mathematics is very much an art form. You can claim that some methods are easy, but there is much credit to be given to those who tried to experiment with the simplest things.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>We can also consider <span class="math inline">\(\mathbb R^n\)</span> instead of <span class="math inline">\(\mathbb R\)</span>. In fact, it would not be difficult to write down some equivalent statement of integration by parts over an arbitrary manifold, but we will leave this discussion to <a href="https://arbourj.wordpress.com/2013/12/19/integration-by-parts-and-greens-formula-on-riemannian-manifolds/">this blog post</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/lekhbhatia\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>